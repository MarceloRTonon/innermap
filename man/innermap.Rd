% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/innermap.R
\name{innermap}
\alias{innermap}
\alias{innermap_lgl}
\alias{innermap_int}
\alias{innermap_dbl}
\alias{innermap_chr}
\alias{innermap_raw}
\alias{innermap_dfr}
\alias{innermap_dfc}
\title{Apply a function to a list or atomic vector using its two elements each time}
\usage{
innermap(input, .f0, distance = 1)

innermap_lgl(input, .f0, distance = 1)

innermap_int(input, .f0, distance = 1)

innermap_dbl(input, .f0, distance = 1)

innermap_chr(input, .f0, distance = 1)

innermap_raw(input, .f0, distance = 1)

innermap_dfr(input, .f0, distance = 1)

innermap_dfc(input, .f0, distance = 1)
}
\arguments{
\item{input}{A list or atomic vector.}

\item{.f0}{A function, formula, or vector (not necessarily atomic)

 If a __function__, it is used as is.

 If a __formula__, e.g. `~ .x + 2`, it is converted to a function. There are three ways to refer to the arguments:

  * For a single argument function, use `.`
  * For a two argument function, use `.x` and `.y`
  * For more arguments, use `..1`, `..2`, `..3` etc

   This syntax allows you to create very compact anonymous functions. Note that formula functions conceptually take dots (that's why you can use `..1` etc). They silently ignore additional arguments that are not used in the formula expression.}

\item{distance}{The distance between each element of the vector. The default value is 1.}
}
\value{
* innermap returns a list with the lenght equals  of the input minus the distance argument..
   * innermap_lgl, innermap_dbl, innermap_int, innermap_chr and innermpa_raw return a atomic vector the type of the pronoun, with the lenght equals of the input minus the distance argument.
   * innermap_dfr and innermap_dfc returns a data.frame
}
\description{
The innermap function applies a function to a list or atomic vectors using its two of their elements in sequence as input. It is different from purrr::accumulate() since it does not use any of its output as an input. Although the innermap family accepts atomic as inputs, the use of the innerApply() function is way more faster.
}
\examples{

library(plyr)
library(magrittr)

# Making cell to cell operations

plyr::alply(ozone, 3) \%>\%
innermap(`/`)


# Making logical operations for the matrices as a
# whole and returning a logical vector

plyr::alply(ozone,3) \%>\%
innermap_lgl(identical)

# Making logical operations for the matrices elements
# and creating a data frame by column-binding it.

plyr::alply(ozone, 3, colMeans) \%>\%
innermap(function(x,y) x <= y)

# Using all.equal for the matrices and returning a character vector.

plyr::alply(ozone, 3) \%>\%
innermap_chr(function(x,y) all.equal(x,y)[1], distance =2)


}
\seealso{
[innerApply()] for applying a function to sequentional elements of an atomic vector, is way more faster than any element of the innermap family.
}
